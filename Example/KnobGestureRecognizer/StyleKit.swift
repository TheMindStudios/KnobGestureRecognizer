//
//  StyleKit.swift
//  (null)
//
//  Created by Hapich Dima on 02.03.17.
//  Copyright Â© 2017 TheMindStudios. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class StyleKit : NSObject {

    //// Drawing Methods

    public dynamic class func drawBackgroundImage(frame: CGRect = CGRect(x: 0, y: 26, width: 325, height: 592), colorFirst: UIColor = UIColor(red: 0.824, green: 0.996, blue: 0.473, alpha: 1.000), colorSecond: UIColor = UIColor(red: 0.991, green: 0.514, blue: 0.343, alpha: 1.000)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let color2 = colorFirst.withAlphaComponent(0.5)
        let color = colorSecond.withAlphaComponent(0.5)
        let strokeColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let fillColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

        //// Gradient Declarations
        let linearGradient2 = CGGradient(colorsSpace: nil, colors: [color2.cgColor, color.cgColor] as CFArray, locations: [0, 1])!
        let linearGradient1 = CGGradient(colorsSpace: nil, colors: [colorFirst.cgColor, colorSecond.cgColor] as CFArray, locations: [0, 1])!

        //// Oval-8 Drawing
        let oval8Path = UIBezierPath()
        oval8Path.move(to: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Path.addLine(to: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.55856 * frame.height))
        oval8Path.addLine(to: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.99850 * frame.height))
        oval8Path.addLine(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 1.00000 * frame.height))
        oval8Path.addLine(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Path.addLine(to: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Path.close()
        context.saveGState()
        oval8Path.addClip()
        let oval8Bounds: CGRect = oval8Path.cgPath.boundingBoxOfPath
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: oval8Bounds.midX + 0 * oval8Bounds.width / 325, y: oval8Bounds.midY + 596 * oval8Bounds.height / 592),
            end: CGPoint(x: oval8Bounds.midX + 0 * oval8Bounds.width / 325, y: oval8Bounds.midY + 232.81 * oval8Bounds.height / 592),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// Oval-8-Copy-4 Drawing
        let oval8Copy4Path = UIBezierPath()
        oval8Copy4Path.move(to: CGPoint(x: frame.minX + 0.99728 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Copy4Path.addCurve(to: CGPoint(x: frame.minX + 0.99827 * frame.width, y: frame.minY + 0.71373 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.99728 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint2: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.56081 * frame.height))
        oval8Copy4Path.addCurve(to: CGPoint(x: frame.minX + 0.15217 * frame.width, y: frame.minY + 0.87538 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.76535 * frame.width, y: frame.minY + 0.81498 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.47153 * frame.width, y: frame.minY + 0.87538 * frame.height))
        oval8Copy4Path.addCurve(to: CGPoint(x: frame.minX + 0.00033 * frame.width, y: frame.minY + 0.87078 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.10085 * frame.width, y: frame.minY + 0.87538 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.05018 * frame.width, y: frame.minY + 0.87382 * frame.height))
        oval8Copy4Path.addCurve(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint1: CGPoint(x: frame.minX + -0.00000 * frame.width, y: frame.minY + 0.70045 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Copy4Path.addLine(to: CGPoint(x: frame.minX + 0.99728 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Copy4Path.close()
        context.saveGState()
        oval8Copy4Path.addClip()
        let oval8Copy4Bounds: CGRect = oval8Copy4Path.cgPath.boundingBoxOfPath
        context.drawLinearGradient(linearGradient2,
            start: CGPoint(x: oval8Copy4Bounds.midX + 0 * oval8Copy4Bounds.width / 324.63, y: oval8Copy4Bounds.midY + 448 * oval8Copy4Bounds.height / 518.22),
            end: CGPoint(x: oval8Copy4Bounds.midX + 0 * oval8Copy4Bounds.width / 324.63, y: oval8Copy4Bounds.midY + 0 * oval8Copy4Bounds.height / 518.22),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// Oval-8-Copy-3 Drawing
        let oval8Copy3Path = UIBezierPath()
        oval8Copy3Path.move(to: CGPoint(x: frame.minX + 0.99728 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Copy3Path.addCurve(to: CGPoint(x: frame.minX + 0.99850 * frame.width, y: frame.minY + 0.25633 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.99728 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.99322 * frame.width, y: frame.minY + 0.20120 * frame.height))
        oval8Copy3Path.addCurve(to: CGPoint(x: frame.minX + 0.17255 * frame.width, y: frame.minY + 0.59610 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.89134 * frame.width, y: frame.minY + 0.45293 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.56341 * frame.width, y: frame.minY + 0.59610 * frame.height))
        oval8Copy3Path.addCurve(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.58709 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.11561 * frame.width, y: frame.minY + 0.59610 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.05387 * frame.width, y: frame.minY + 0.59289 * frame.height))
        oval8Copy3Path.addCurve(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.00615 * frame.width, y: frame.minY + 0.41349 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Copy3Path.addLine(to: CGPoint(x: frame.minX + 0.99728 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Copy3Path.close()
        context.saveGState()
        oval8Copy3Path.addClip()
        let oval8Copy3Bounds: CGRect = oval8Copy3Path.cgPath.boundingBoxOfPath
        context.drawLinearGradient(linearGradient2,
            start: CGPoint(x: oval8Copy3Bounds.midX + 0 * oval8Copy3Bounds.width / 324.51, y: oval8Copy3Bounds.midY + 283.11 * oval8Copy3Bounds.height / 352.89),
            end: CGPoint(x: oval8Copy3Bounds.midX + 0 * oval8Copy3Bounds.width / 324.51, y: oval8Copy3Bounds.midY + 0 * oval8Copy3Bounds.height / 352.89),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// Oval-8-Copy-2 Drawing
        let oval8Copy2Path = UIBezierPath()
        oval8Copy2Path.move(to: CGPoint(x: frame.minX + 0.54978 * frame.width, y: frame.minY + 0.00444 * frame.height))
        oval8Copy2Path.addCurve(to: CGPoint(x: frame.minX + 0.60598 * frame.width, y: frame.minY + 0.12462 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.58558 * frame.width, y: frame.minY + 0.04003 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.60598 * frame.width, y: frame.minY + 0.08101 * frame.height))
        oval8Copy2Path.addCurve(to: CGPoint(x: frame.minX + 0.15761 * frame.width, y: frame.minY + 0.37237 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.60598 * frame.width, y: frame.minY + 0.26145 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.40524 * frame.width, y: frame.minY + 0.37237 * frame.height))
        oval8Copy2Path.addCurve(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.35886 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.10490 * frame.width, y: frame.minY + 0.37237 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.04698 * frame.width, y: frame.minY + 0.36809 * frame.height))
        oval8Copy2Path.addCurve(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.00272 * frame.width, y: frame.minY + 0.25150 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8Copy2Path.addCurve(to: CGPoint(x: frame.minX + 0.54978 * frame.width, y: frame.minY + 0.00444 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.38315 * frame.width, y: frame.minY + 0.00075 * frame.height))
        oval8Copy2Path.close()
        context.saveGState()
        oval8Copy2Path.addClip()
        let oval8Copy2Bounds: CGRect = oval8Copy2Path.cgPath.boundingBoxOfPath
        context.drawLinearGradient(linearGradient2,
            start: CGPoint(x: oval8Copy2Bounds.midX + 0 * oval8Copy2Bounds.width / 196.94, y: oval8Copy2Bounds.midY + 146.67 * oval8Copy2Bounds.height / 220.44),
            end: CGPoint(x: oval8Copy2Bounds.midX + 0 * oval8Copy2Bounds.width / 196.94, y: oval8Copy2Bounds.midY + -10.62 * oval8Copy2Bounds.height / 220.44),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// Oval-8-Copy- Drawing
        let oval8CopyPath = UIBezierPath()
        oval8CopyPath.move(to: CGPoint(x: frame.minX + 0.99728 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8CopyPath.addCurve(to: CGPoint(x: frame.minX + 0.99884 * frame.width, y: frame.minY + 0.25571 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.99728 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.98916 * frame.width, y: frame.minY + 0.21246 * frame.height))
        oval8CopyPath.addCurve(to: CGPoint(x: frame.minX + 0.17255 * frame.width, y: frame.minY + 0.59610 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.89203 * frame.width, y: frame.minY + 0.45263 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.56383 * frame.width, y: frame.minY + 0.59610 * frame.height))
        oval8CopyPath.addCurve(to: CGPoint(x: frame.minX + 0.00081 * frame.width, y: frame.minY + 0.58668 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.11375 * frame.width, y: frame.minY + 0.59610 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.05632 * frame.width, y: frame.minY + 0.59286 * frame.height))
        oval8CopyPath.addCurve(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.00408 * frame.width, y: frame.minY + 0.43318 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8CopyPath.addLine(to: CGPoint(x: frame.minX + 0.99728 * frame.width, y: frame.minY + 0.00000 * frame.height))
        oval8CopyPath.close()
        context.saveGState()
        oval8CopyPath.addClip()
        let oval8CopyBounds: CGRect = oval8CopyPath.cgPath.boundingBoxOfPath
        context.drawLinearGradient(linearGradient2,
            start: CGPoint(x: oval8CopyBounds.midX + 0 * oval8CopyBounds.width / 324.62, y: oval8CopyBounds.midY + 283.11 * oval8CopyBounds.height / 352.89),
            end: CGPoint(x: oval8CopyBounds.midX + 0 * oval8CopyBounds.width / 324.62, y: oval8CopyBounds.midY + 0 * oval8CopyBounds.height / 352.89),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// Oval-8-Copy 5 Drawing
        let oval8Copy5Rect = CGRect(x: frame.minX + fastFloor(frame.width * 0.02462 + 0.5), y: frame.minY + fastFloor(frame.height * 0.06250 + 0.5), width: fastFloor(frame.width * 0.36308 + 0.5) - fastFloor(frame.width * 0.02462 + 0.5), height: fastFloor(frame.height * 0.24831 + 0.5) - fastFloor(frame.height * 0.06250 + 0.5))
        let oval8Copy5Path = UIBezierPath(ovalIn: oval8Copy5Rect)
        context.saveGState()
        oval8Copy5Path.addClip()
        context.drawLinearGradient(linearGradient1,
            start: CGPoint(x: oval8Copy5Rect.midX + 0 * oval8Copy5Rect.width / 110, y: oval8Copy5Rect.midY + 55 * oval8Copy5Rect.height / 110),
            end: CGPoint(x: oval8Copy5Rect.midX + 0 * oval8Copy5Rect.width / 110, y: oval8Copy5Rect.midY + -55 * oval8Copy5Rect.height / 110),
            options: [.drawsBeforeStartLocation, .drawsAfterEndLocation])
        context.restoreGState()


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 0.20308 * frame.width, y: frame.minY + 0.16055 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.21385 * frame.width, y: frame.minY + 0.16976 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.20943 * frame.width, y: frame.minY + 0.16215 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.21385 * frame.width, y: frame.minY + 0.16567 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.19538 * frame.width, y: frame.minY + 0.17990 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.21385 * frame.width, y: frame.minY + 0.17536 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.20558 * frame.width, y: frame.minY + 0.17990 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.17692 * frame.width, y: frame.minY + 0.16976 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.18519 * frame.width, y: frame.minY + 0.17990 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.17692 * frame.width, y: frame.minY + 0.17536 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.18769 * frame.width, y: frame.minY + 0.16055 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.17692 * frame.width, y: frame.minY + 0.16567 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.18134 * frame.width, y: frame.minY + 0.16215 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.18769 * frame.width, y: frame.minY + 0.13345 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.19538 * frame.width, y: frame.minY + 0.12922 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.18769 * frame.width, y: frame.minY + 0.13112 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.19111 * frame.width, y: frame.minY + 0.12922 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.20308 * frame.width, y: frame.minY + 0.13345 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.19963 * frame.width, y: frame.minY + 0.12922 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.20308 * frame.width, y: frame.minY + 0.13110 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.20308 * frame.width, y: frame.minY + 0.16055 * frame.height))
        bezierPath.close()
        strokeColor.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()


        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: frame.minX + 0.19846 * frame.width, y: frame.minY + 0.16322 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.20769 * frame.width, y: frame.minY + 0.16976 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.20377 * frame.width, y: frame.minY + 0.16397 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.20769 * frame.width, y: frame.minY + 0.16662 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.19538 * frame.width, y: frame.minY + 0.17652 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.20769 * frame.width, y: frame.minY + 0.17350 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.20218 * frame.width, y: frame.minY + 0.17652 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.18308 * frame.width, y: frame.minY + 0.16976 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.18859 * frame.width, y: frame.minY + 0.17652 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.18308 * frame.width, y: frame.minY + 0.17350 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.19231 * frame.width, y: frame.minY + 0.16322 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.18308 * frame.width, y: frame.minY + 0.16662 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.18700 * frame.width, y: frame.minY + 0.16397 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.19231 * frame.width, y: frame.minY + 0.14949 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.19846 * frame.width, y: frame.minY + 0.14949 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.19846 * frame.width, y: frame.minY + 0.16322 * frame.height))
        bezier2Path.close()
        bezier2Path.usesEvenOddFillRule = true
        fillColor.setFill()
        bezier2Path.fill()
    }

    //// Generated Images

    public dynamic class func imageOfBackgroundImage(imageSize: CGSize = CGSize(width: 325, height: 592), colorFirst: UIColor = UIColor(red: 0.824, green: 0.996, blue: 0.473, alpha: 1.000), colorSecond: UIColor = UIColor(red: 0.991, green: 0.514, blue: 0.343, alpha: 1.000)) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(imageSize, false, 0)
            StyleKit.drawBackgroundImage(frame: CGRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height), colorFirst: colorFirst, colorSecond: colorSecond)

        let imageOfBackgroundImage = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfBackgroundImage
    }

}
